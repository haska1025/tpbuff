#include "tp_cxx_generator.h"

static int tp_gen_cxx_getter_setter(FILE *out, struct item_node *n)
{
    for (struct item_node *in = n; in != NULL; in=in->next){
        if (in->val_type == VALUE_TYPE_INT16){
            fprintf(out, "  int16_t %s(){return %s_;}\n", in->name);
            fprintf(out, "  void %s(int16_t i){%s_=i;}\n", in->name);
        }else if (in->val_type == VALUE_TYPE_INT32){
            fprintf(out, "  int32_t %s(){return %s_;}\n", in->name);
            fprintf(out, "  void %s(int32_t i){%s_=i;}\n", in->name);
        }
    }
}
static int tp_gen_cxx_data_member(FILE *out, struct item_node *n)
{
}
static int tp_gen_cxx_proto(FILE *out, struct protocol *p)
{
    //Generate class header
    fprintf(out, "class %s : public Command {\npublic:\n ", p->name);
    fprintf(out, "  // constructor\n");
    fprintf(out, "  %s();\n", p->name);
    fprintf(out, "  // destructor\n");
    fprintf(out, "  ~%s();\n", p->name);
    fprintf(out, "  // Convert object to bytes stream\n");
    fprintf(out, "  virtual bool Serialize(OutputArchive *archive);\n");
    fprintf(out, "  // Convert bytes stream to object\n");
    fprintf(out, "  virtual bool Deserialize(InputArchive *archive);\n");
    fprintf(out, "  // Return the size of the object\n");
    fprintf(out, "  int ByteSize();\n");
    tp_gen_cxx_getter_setter(out, p->head);
    tp_gen_cxx_data_member(out, p->head);
    fprintf(out, "};\n\n");

    return 0;
}

static int tp_gen_cxx_inc_file(FILE *out)
{
}
int tp_gen_cxx_byte();
int tp_gen_cxx_int16();
int tp_gen_cxx_int32();
int tp_gen_cxx_int64();
int tp_gen_cxx_uint16();
int tp_gen_cxx_uint32();
int tp_gen_cxx_uint64();
int tp_gen_cxx_str();
int tp_gen_cxx_double();
int tp_gen_cxx_float();

int tp_gen_cxx_code(const char *file)
{
    // Openfile
    FILE *hdrfile, *srcfile;
    struct protocol *proto;

    char hdrfilename[GEN_HDR_LEN]={0};
    char srcfilename[GEN_SRC_LEN]={0};

    hdrfile = srcfile = protofile = NULL;
    if ((proto=tpp_protocol_parse(file)) != 0){
        fprintf(stderr, "Parse the protocol failed\n");
        return -1;
    }
    snprintf(hdrfilename, MAX_NAME-1, "%s%s", file, ".tpp.h"); 
    snprintf(srcfilename, MAX_NAME-1, "%s%s", file, ".tpp.cpp"); 
    // Create file for name.tpp.h
    hdrfile = fopen(hdrfilename, "w+");
    if (!hdrfile){
        fprintf(stderr, "Create the hdr file(%s) failed\n", hdrfilename);
        return -1;
    }
    // Create file for name.tpp.cpp
    srcfile = fopen(srcfilename, "w+");
    if (!hdrfile){
        fprintf(stderr, "Create the src file(%s) failed\n", srcfilename);
        fclose(hdrfile);
        return -1;
    }
    // Generate file header
    fprintf(hdrfilename, "/// Generated by tpp compiler. Don't edit!\n");
    fprintf(hdrfilename, "#ifndef _TPP_%s_TPP_H_\n#define _TPP_%s_TPP_H_\n", file, file);
    fprintf(hdrfilename, "#ifdef __cplusplus\nextern " "C" "{\n #endif\n");

    // Generate include file
    if (tp_gen_cxx_inc_file(hdrfilename) != 0){
        // Generate include file failed
        return -1;
    }

    // Generate Protocol
    for (struct protocol *p = proto; p != NULL; p=p->next){
        tp_gen_cxx_proto(hdrfilename, p);
    }

    fprintf(hdrfilename, "#ifdef __cplusplus\n}\n #endif\n");
}

